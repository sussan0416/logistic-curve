<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ロジスティック関数 パラメータ可視化</title>
  <style>
    :root { --pad: 16px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif; margin: 0; }
    header { padding: var(--pad); border-bottom: 1px solid #e5e5e5; }
    main { display: grid; grid-template-columns: 360px 1fr; gap: 12px; padding: var(--pad); }
    @media (max-width: 900px) { main { grid-template-columns: 1fr; } }

    .panel { border: 1px solid #e5e5e5; border-radius: 12px; padding: 12px; }
    .row { display: grid; grid-template-columns: 1fr 92px; gap: 8px; align-items: center; margin: 10px 0; }
    .row label { font-size: 14px; }
    input[type="range"] { width: 100%; }
    input[type="number"] { width: 100%; padding: 6px 8px; }
    .hint { color: #555; font-size: 12px; line-height: 1.5; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Noto Sans Mono", monospace; }

    canvas { width: 100%; height: 520px; border-radius: 12px; border: 1px solid #e5e5e5; background: #fff; }
    .kpis { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
    .kpi { border: 1px solid #eee; border-radius: 10px; padding: 10px; }
    .kpi .t { font-size: 12px; color: #666; }
    .kpi .v { font-size: 14px; font-weight: 600; margin-top: 4px; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #ddd; background: #fafafa; cursor: pointer; }
    button:hover { background: #f3f3f3; }
    .btns { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
  </style>
</head>
<body>
  <header>
    <div style="display:flex; justify-content:space-between; gap:12px; align-items:flex-start; flex-wrap:wrap;">
      <div>
        <div style="font-weight:700;">ロジスティック関数：パラメータで曲線がどう変わるか</div>
        <div class="hint">式：<span class="mono">y(x) = A + (K-A) / (1 + exp(-B(x-M)))</span></div>
      </div>
      <div class="btns">
        <button id="presetStandard">標準</button>
        <button id="presetSteep">急峻</button>
        <button id="presetReverse">反転</button>
        <button id="presetWide">ゆるやか</button>
      </div>
    </div>
  </header>

  <main>
    <section class="panel" aria-label="controls">
      <div style="font-weight:700; margin-bottom:8px;">パラメータ</div>

      <div class="row">
        <label for="A">A（下限）</label>
        <input id="A" type="number" step="0.1" />
      </div>
      <input id="A_range" type="range" step="0.1" />

      <div class="row">
        <label for="K">K（上限）</label>
        <input id="K" type="number" step="0.1" />
      </div>
      <input id="K_range" type="range" step="0.1" />

      <div class="row">
        <label for="B">B（傾き・急峻さ）</label>
        <input id="B" type="number" step="0.1" />
      </div>
      <input id="B_range" type="range" step="0.1" />

      <div class="row">
        <label for="M">M（中心 / 変曲点x）</label>
        <input id="M" type="number" step="0.1" />
      </div>
      <input id="M_range" type="range" step="0.1" />

      <hr style="border:none;border-top:1px solid #eee;margin:14px 0;">

      <div style="font-weight:700; margin-bottom:8px;">表示範囲</div>

      <div class="row">
        <label for="xmin">x最小</label>
        <input id="xmin" type="number" step="0.5" />
      </div>
      <input id="xmin_range" type="range" step="0.5" />

      <div class="row">
        <label for="xmax">x最大</label>
        <input id="xmax" type="number" step="0.5" />
      </div>
      <input id="xmax_range" type="range" step="0.5" />

      <div class="row">
        <label for="points">点の数（滑らかさ）</label>
        <input id="points" type="number" step="10" />
      </div>
      <input id="points_range" type="range" step="10" />

      <div class="kpis">
        <div class="kpi">
          <div class="t">変曲点（x=M）</div>
          <div class="v mono" id="inflection"></div>
        </div>
        <div class="kpi">
          <div class="t">変曲点の傾き dy/dx</div>
          <div class="v mono" id="slopeAtM"></div>
        </div>
        <div class="kpi">
          <div class="t">下限（A）</div>
          <div class="v mono" id="lowerAsym"></div>
        </div>
        <div class="kpi">
          <div class="t">上限（K）</div>
          <div class="v mono" id="upperAsym"></div>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid #eee;margin:14px 0;">

      <div class="hint">
        <div style="font-weight:700;margin-bottom:6px;">見どころ</div>
        <ul style="margin:0;padding-left:18px;">
          <li><span class="mono">M</span> を動かす → S字が左右に平行移動</li>
          <li><span class="mono">A/K</span> を動かす → 下限/上限が上下に移動（縦方向スケール含む）</li>
          <li><span class="mono">B</span> を大きく → 立ち上がりが急に（負だと右下がり）</li>
        </ul>
        <div style="margin-top:8px;">
          変曲点の傾きは <span class="mono">dy/dx |x=M = (K-A) * B / 4</span>。
          <br/>「<span class="mono">B</span> だけじゃなく <span class="mono">(K-A)</span> も急峻さに効く」のが見落としポイント。
        </div>
      </div>
    </section>

    <section class="panel" aria-label="plot">
      <canvas id="cv" width="1200" height="650"></canvas>
      <div class="hint" style="margin-top:10px;">
        グラフ上の破線：<span class="mono">x=M</span>（中心）と <span class="mono">y=A</span>, <span class="mono">y=K</span>（漸近線）。
      </div>
    </section>
  </main>

  <script>
    // ---- math ----
    function logistic(x, A, K, B, M) {
      // stable-ish exp: clamp exponent to avoid overflow
      const z = -B * (x - M);
      const zz = Math.max(-60, Math.min(60, z));
      return A + (K - A) / (1 + Math.exp(zz));
    }

    function slopeAtInflection(A, K, B) {
      return (K - A) * B / 4;
    }

    // ---- ui helpers ----
    const els = {};
    [
      "A","K","B","M",
      "A_range","K_range","B_range","M_range",
      "xmin","xmax","points",
      "xmin_range","xmax_range","points_range",
      "inflection","slopeAtM","lowerAsym","upperAsym",
      "presetStandard","presetSteep","presetReverse","presetWide"
    ].forEach(id => els[id] = document.getElementById(id));

    function bindPair(numEl, rangeEl, onChange) {
      const syncFromNum = () => { rangeEl.value = numEl.value; onChange(); };
      const syncFromRange = () => { numEl.value = rangeEl.value; onChange(); };
      numEl.addEventListener("input", syncFromNum);
      rangeEl.addEventListener("input", syncFromRange);
    }

    function setRange(el, min, max, value) {
      el.min = min; el.max = max; el.value = value;
    }

    // ---- canvas drawing ----
    const cv = document.getElementById("cv");
    const ctx = cv.getContext("2d");

    function draw() {
      const A = parseFloat(els.A.value);
      const K = parseFloat(els.K.value);
      const B = parseFloat(els.B.value);
      const M = parseFloat(els.M.value);

      const xmin = parseFloat(els.xmin.value);
      const xmax = parseFloat(els.xmax.value);
      const n = Math.max(20, Math.floor(parseFloat(els.points.value)));

      // compute y range (include asymptotes)
      let ys = [];
      for (let i=0;i<=n;i++) {
        const x = xmin + (xmax - xmin) * (i / n);
        ys.push(logistic(x, A, K, B, M));
      }
      ys.push(A, K);
      const yMin = Math.min(...ys);
      const yMax = Math.max(...ys);

      // padding
      const padL = 70, padR = 20, padT = 20, padB = 55;
      const W = cv.width, H = cv.height;
      const plotW = W - padL - padR;
      const plotH = H - padT - padB;

      const xToPx = (x) => padL + (x - xmin) / (xmax - xmin) * plotW;
      const yToPx = (y) => padT + (yMax - y) / (yMax - yMin) * plotH;

      // clear
      ctx.clearRect(0,0,W,H);

      // axes
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#222";
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, padT + plotH);
      ctx.lineTo(padL + plotW, padT + plotH);
      ctx.stroke();

      // ticks
      ctx.fillStyle = "#222";
      ctx.font = "14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

      function niceTicks(min, max, count) {
        const span = max - min;
        if (span <= 0) return [min];
        const rawStep = span / count;
        const pow10 = Math.pow(10, Math.floor(Math.log10(rawStep)));
        const steps = [1,2,5,10].map(m => m * pow10);
        let step = steps[0];
        for (const s of steps) if (Math.abs(rawStep - s) < Math.abs(rawStep - step)) step = s;
        const start = Math.ceil(min / step) * step;
        let arr = [];
        for (let v=start; v<=max+1e-9; v+=step) arr.push(v);
        return arr;
      }

      // x ticks
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      for (const x of niceTicks(xmin, xmax, 8)) {
        const px = xToPx(x);
        ctx.strokeStyle = "#ddd";
        ctx.beginPath();
        ctx.moveTo(px, padT);
        ctx.lineTo(px, padT + plotH);
        ctx.stroke();

        ctx.fillStyle = "#222";
        ctx.fillText(x.toFixed(2).replace(/\.00$/,""), px, padT + plotH + 6);
      }

      // y ticks
      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      for (const y of niceTicks(yMin, yMax, 6)) {
        const py = yToPx(y);
        ctx.strokeStyle = "#ddd";
        ctx.beginPath();
        ctx.moveTo(padL, py);
        ctx.lineTo(padL + plotW, py);
        ctx.stroke();

        ctx.fillStyle = "#222";
        ctx.fillText(y.toFixed(2).replace(/\.00$/,""), padL - 8, py);
      }

      // guide lines: y=A, y=K, x=M
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = "#888";
      ctx.lineWidth = 1;

      // y=A
      const yA = yToPx(A);
      ctx.beginPath();
      ctx.moveTo(padL, yA);
      ctx.lineTo(padL + plotW, yA);
      ctx.stroke();

      // y=K
      const yK = yToPx(K);
      ctx.beginPath();
      ctx.moveTo(padL, yK);
      ctx.lineTo(padL + plotW, yK);
      ctx.stroke();

      // x=M
      const xM = xToPx(M);
      ctx.beginPath();
      ctx.moveTo(xM, padT);
      ctx.lineTo(xM, padT + plotH);
      ctx.stroke();

      ctx.setLineDash([]);

      // curve
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i=0;i<=n;i++) {
        const x = xmin + (xmax - xmin) * (i / n);
        const y = logistic(x, A, K, B, M);
        const px = xToPx(x);
        const py = yToPx(y);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();

      // highlight inflection point
      const yAtM = logistic(M, A, K, B, M); // should be (A+K)/2
      const pxi = xToPx(M);
      const pyi = yToPx(yAtM);
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(pxi, pyi, 5, 0, Math.PI*2);
      ctx.fill();

      // labels
      ctx.font = "13px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
      ctx.fillStyle = "#111";
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText(`x=M (${M.toFixed(2)})`, pxi + 8, padT + 8);
      ctx.fillText(`y=A (${A.toFixed(2)})`, padL + 8, yA + 6);
      ctx.fillText(`y=K (${K.toFixed(2)})`, padL + 8, yK + 6);

      // update kpis
      els.inflection.textContent = `(${M.toFixed(4)}, ${(yAtM).toFixed(4)})`;
      els.slopeAtM.textContent = `${slopeAtInflection(A, K, B).toFixed(6)}`;
      els.lowerAsym.textContent = `${A.toFixed(4)}`;
      els.upperAsym.textContent = `${K.toFixed(4)}`;
    }

    // ---- init defaults & ranges ----
    function setParams({A, K, B, M, xmin, xmax, points}) {
      els.A.value = A; els.K.value = K; els.B.value = B; els.M.value = M;
      els.xmin.value = xmin; els.xmax.value = xmax; els.points.value = points;

      els.A_range.value = A; els.K_range.value = K; els.B_range.value = B; els.M_range.value = M;
      els.xmin_range.value = xmin; els.xmax_range.value = xmax; els.points_range.value = points;

      draw();
    }

    // Parameter ranges (いったん学習向けに広め)
    setRange(els.A_range, -10, 10, 0);
    setRange(els.K_range, -10, 10, 1);
    setRange(els.B_range, -10, 10, 1);
    setRange(els.M_range, -10, 10, 0);

    setRange(els.xmin_range, -20, 0, -6);
    setRange(els.xmax_range, 0, 20, 6);
    setRange(els.points_range, 50, 2000, 500);

    // Numbers also get sensible defaults
    setParams({A: 0, K: 1, B: 1, M: 0, xmin: -6, xmax: 6, points: 500});

    // Bind pairs
    bindPair(els.A, els.A_range, draw);
    bindPair(els.K, els.K_range, draw);
    bindPair(els.B, els.B_range, draw);
    bindPair(els.M, els.M_range, draw);
    bindPair(els.xmin, els.xmin_range, draw);
    bindPair(els.xmax, els.xmax_range, draw);
    bindPair(els.points, els.points_range, draw);

    // Guard: xmin < xmax
    function normalizeX() {
      let a = parseFloat(els.xmin.value);
      let b = parseFloat(els.xmax.value);
      if (a >= b) {
        b = a + 0.5;
        els.xmax.value = b;
        els.xmax_range.value = b;
      }
    }
    els.xmin.addEventListener("change", () => { normalizeX(); draw(); });
    els.xmax.addEventListener("change", () => { normalizeX(); draw(); });

    // Presets
    els.presetStandard.addEventListener("click", () => setParams({A:0, K:1, B:1, M:0, xmin:-6, xmax:6, points:500}));
    els.presetSteep.addEventListener("click", () => setParams({A:0, K:1, B:6, M:0, xmin:-2, xmax:2, points:600}));
    els.presetReverse.addEventListener("click", () => setParams({A:0, K:1, B:-3, M:0, xmin:-6, xmax:6, points:500}));
    els.presetWide.addEventListener("click", () => setParams({A:-1, K:2, B:0.8, M:1.5, xmin:-10, xmax:10, points:700}));

    // redraw on resize for crispness (canvas size fixed; but still ok)
    window.addEventListener("resize", draw);
  </script>
</body>
</html>
